# 响应式原理

## reactive 这个函数有什么用

`reactive` 接收一个**对象**，并返回一个**代理对象**。在effect中对代理对象进行取值操作时，会对该属性进行**依赖收集**，并在该属性重新赋值的时候**触发依赖**， 即重新运行所有依赖该属性的`effect`

## effect 这个函数有什么用

`effect` 接收一个**函数**和一个**选项**并返回一个`runner`，`effect` 会立即执行该函数，如果该函数中对**响应式对象**有**取值**操作，则会对该属性进行**依赖收集**，并在该属性变化（赋值）的时候重新运行该函数。

对于返回的`runner` 可以调用它来执行传入的函数 在选项中可以传入**调度函数**(scheduler)来覆盖effect默认的调度函数, 通过传入调度函数与返回的`runner`做配合, 可以在函数重新执行前做额外的操作,实现**切面编程**的效果
```ts
const runner = effect(() => {}, { scheduler: () => {
  // 额外的操作
  runner()
} })
```

## 依赖收集 & 依赖触发 & 依赖清理

### 依赖收集

`reactive` 返回的的是一个代理对象 ，对`reactive`取值时，会触发`get` 操作，如果取值操作是在`effect`中，会进行**依赖收集**

有一个全局的依赖表`targetMap` 会记录所有的属性和`effect`的依赖关系，`targetMap`的数据结构形如
```ts
{
  {name: "zx", age: 18}: {
    name: {
      effect1,
      effect2
    },
    age: {
      effect1
    }
  }
}
```

初次收集时, `track`方法会创建一个类似上述结构的依赖关系 并将当前触发该收集的`effect`存入依赖关系, 并且在`effect`实例中会维护一个`deps`数组存储effect对应的依赖, 如果`effect`重新运行, 会触发重新`收集依赖` 此时会有一个简单的diff算法, 如果收集的依赖相同会则复用, 如果不同则触发**依赖清理**并添加新的依赖项.

### 依赖清理

`effect` 执行前会先进行**依赖预清理**, 在`effect`执行后会进行**依赖后清理** 在依赖收集过程中如果当前收集的依赖和上一次收集的依赖不相同，会触发**依赖清理**并添加新的依赖项

依赖预清理 将`effect`内的维护的依赖长度清零, 等待diff

依赖后清理 查看依赖数组的长度和维护依赖长度, 如果数组长度大于维护依赖长度, 则清理多出的依赖

### 依赖触发

对被依赖收过的响应式对象进行赋值操作时,如果新旧值不相等,会**依赖触发**. 依赖触发时,在`targetMap`取出依赖对应的所有`effect`, 依次触发`effect`
